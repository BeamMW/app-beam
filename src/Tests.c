// Copyright 2018 The Beam Team
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "cx.h"
#include "BeamApp.h"
#include "sw.h"

#include "hw_crypto/keykeeper.h"
#include "hw_crypto/multimac.h"
#include "hw_crypto/rangeproof.h"

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-function"
#include "secp256k1/src/hash_impl.h"
#pragma GCC diagnostic pop


#define c_Modal_Ok 1
#define c_Modal_Cancel 2

void DeriveAddress(const KeyKeeper* p, AddrID addrID, secp256k1_scalar* pKey, UintBig* pAddr);

__attribute__((noinline))
void DeriveAddress2(const KeyKeeper* p, AddrID addrID, UintBig* pAddr)
{
    secp256k1_scalar sk;
    DeriveAddress(p, addrID, &sk, pAddr);
}

KeyKeeper* KeyKeeper_Get();


#pragma pack (push, 1)
#define THE_FIELD(type, name) type m_##name;

#define THE_MACRO(id, name) \
typedef struct { uint8_t m_OpCode; BeamCrypto_ProtoRequest_##name(THE_FIELD) } Proto_In_##name; \
typedef struct { uint8_t m_RetVal; BeamCrypto_ProtoResponse_##name(THE_FIELD) } Proto_Out_##name; \
const uint8_t g_Proto_Code_##name = id;

BeamCrypto_ProtoMethods(THE_MACRO)
#undef THE_MACRO
#undef THE_FIELD

#pragma pack (pop)



int KeyKeeper_InvokeExact(KeyKeeper* p, uint8_t* pInOut, uint32_t nIn, uint32_t nOut)
{
    return KeyKeeper_Invoke(p, pInOut, nIn, pInOut, &nOut);
}

void OnSomeDemo()
{
    KeyKeeper kk;
    UintBig hv;
    CompactPoint pPt[2];


    // for fun!
    memset(&hv, 0x11, sizeof(hv));
    Kdf_Init(&kk.m_MasterKey, &hv);

    RangeProof rp;
    memset(&rp, 0, sizeof(rp));

    rp.m_pKdf = &kk.m_MasterKey;

    rp.m_Cid.m_Amount = 400000;
    rp.m_Cid.m_Idx = 15;
    rp.m_Cid.m_Type = 0x22;
    rp.m_Cid.m_SubIdx = 8;
    rp.m_Cid.m_Amount = 4500000000ull;
    rp.m_Cid.m_AssetID = 0;

    memset(pPt, 0, sizeof(pPt));
    rp.m_pT_In = pPt;
    rp.m_pT_Out = pPt;
    rp.m_pTauX = (secp256k1_scalar*)&hv;

    RangeProof_Calculate(&rp);

    KeyKeeper_DisplayEndpoint(&kk, 15, &hv);

}

void Alert(const char* sz, uint32_t n);

void BeamStackTest1()
{
    union {

        struct {
            Kdf kdf1;
            Kdf kdf2;
            UintBig hv;
        } p1;

        struct {
            secp256k1_scalar s1, s2;
            MultiMac_WNaf wnaf;
            MultiMac_Context mmCtx;
            secp256k1_gej gej;
        } p2;

        struct {
            Kdf kdf;
            CoinID cid;
            secp256k1_scalar s;
            secp256k1_gej gej;

            struct {
                secp256k1_ge_storage m_pPt[c_MultiMac_OddCount(c_MultiMac_nBits_Custom)];
                secp256k1_fe zDenom;
            } aGen;

        } p3;


        struct {
            Kdf kdf;
            secp256k1_scalar tauX;
            CompactPoint pT[2];
            RangeProof rp;
        } p4;

        uint8_t m_pArr[4];
        uint32_t m_TheVal;

    } u;

    u.m_TheVal = 0;
    u.m_pArr[0] = 1;
    PRINTF("@@ TheVal = %u\n", u.m_TheVal);

    u.m_TheVal = __builtin_bswap32(u.m_TheVal);
    PRINTF("@@ TheVal = %u\n", u.m_TheVal);

#ifdef STACK_CANARY
    PRINTF("@@ Stack available: %u\n", ((uint8_t*) &u) - ((uint8_t*) &_stack));
#endif // STACK_CANARY

    PRINTF("@@ FastGen-custom size = %u\n", sizeof(u.p3.aGen));

    StackMark();

    memset(&u.p1.hv, 0, sizeof(u.p1.hv));
    Kdf_Init(&u.p1.kdf1, &u.p1.hv);

    StackPrint(&u, "Kdf_Init");
    StackMark();

    Kdf_getChild(&u.p1.kdf2, 14, &u.p1.kdf1);

    StackPrint(&u, "Kdf_getChild");
    StackMark();

    memset(&u.p2.s1, 0xa5, sizeof(u.p2.s1));
    memset(&u.p2.s2, 0x6c, sizeof(u.p2.s2));
    memset(&u.p2.mmCtx, 0, sizeof(u.p2.mmCtx));

    u.p2.mmCtx.m_pRes = &u.p2.gej;
    u.p2.mmCtx.m_Secure.m_Count = 1;
    u.p2.mmCtx.m_Secure.m_pK = &u.p2.s1;
    u.p2.mmCtx.m_Secure.m_pGen = Context_get()->m_pGenGJ;
    u.p2.mmCtx.m_Fast.m_Count = 1;
    u.p2.mmCtx.m_Fast.m_pK = &u.p2.s2;
    u.p2.mmCtx.m_Fast.m_pWnaf = &u.p2.wnaf;
    u.p2.mmCtx.m_Fast.m_pGen0 = Context_get()->m_pGenH;
    u.p2.mmCtx.m_Fast.m_WndBits = c_MultiMac_nBits_H;
    u.p2.mmCtx.m_Fast.m_pZDenom = 0;

    MultiMac_Calculate(&u.p2.mmCtx);

    StackPrint(&u, "MultiMac_Calculate");


    StackMark();
    void CoinID_GenerateAGen(AssetID aid, void* pAGen);
    CoinID_GenerateAGen(42, &u.p3.aGen);
    StackPrint(&u, "CoinID_GenerateAGen");


    Kdf_Init(&u.p3.kdf, &u.p1.hv); // don't care if p1.hv contains garbage

    memset(&u.p3.cid, 0, sizeof(u.p3.cid));
    u.p3.cid.m_Idx = 15;
    u.p3.cid.m_Type = 0x22;
    u.p3.cid.m_SubIdx = 8;
    u.p3.cid.m_Amount = 4500000000ull;
    u.p3.cid.m_AssetID = 0;

    StackMark();
    void CoinID_getCommRaw(const secp256k1_scalar* pK, Amount amount, const void* pAGen, secp256k1_gej* pGej);
    CoinID_getCommRaw(&u.p3.s, u.p3.cid.m_Amount, 0, &u.p3.gej);
    StackPrint(&u, "CoinID_getCommRaw without aid");

    StackMark();
    CoinID_getSkComm(&u.p3.kdf, &u.p3.cid, &u.p3.s, 0);
    StackPrint(&u, "CoinID_getSk without aid");


    u.p3.cid.m_AssetID = 42;

    StackMark();
    CoinID_getCommRaw(&u.p3.s, u.p3.cid.m_Amount, &u.p3.aGen, &u.p3.gej);
    StackPrint(&u, "CoinID_getCommRaw with aid");

    StackMark();
    CoinID_getSkComm(&u.p3.kdf, &u.p3.cid, &u.p3.s, 0);
    StackPrint(&u, "CoinID_getSk with aid");

    memset(&u.p4, 0, sizeof(u.p4));
    Kdf_Init(&u.p4.kdf, &u.p1.hv); // don't care if p1.hv contains garbage

    u.p4.rp.m_Cid.m_Amount = 774440000;
    u.p4.rp.m_Cid.m_SubIdx = 45;
    u.p4.rp.m_Cid.m_AssetID = 8;
    u.p4.rp.m_pKdf = &u.p4.kdf;
    u.p4.rp.m_pT_In = u.p4.pT;
    u.p4.rp.m_pT_Out = u.p4.pT;
    u.p4.rp.m_pTauX = &u.p4.tauX;

    StackMark();
    RangeProof_Calculate(&u.p4.rp);
    StackPrint(&u, "RangeProof_Calculate");

}

void BeamStackTest2()
{
    struct
    {
        KeyKeeper kk1;
        KeyKeeper kk2;

        TxCommonOut m_TxAux;
        UintBig m_hvUserAggr;

        union
        {
            UintBig hv;
            secp256k1_scalar kTmp;

            union {
                Proto_In_GetNumSlots m_In;
                Proto_Out_GetNumSlots m_Out;
            } p1;

#pragma pack (push, 1)
            struct {

                Proto_In_TxAddCoins m_In;
                CoinID m_pCid[2];

            } p2;
#pragma pack (pop)

            union {
                Proto_In_TxSend1 m_In;
                Proto_Out_TxSend1 m_Out;
            } p3;

            union {
                Proto_In_TxReceive m_In;
                Proto_Out_TxReceive m_Out;
            } p4;

            union {
                Proto_In_TxSend2 m_In;
                Proto_Out_TxSend2 m_Out;
            } p5;

            union {
                Proto_In_CreateOutput m_In;
                Proto_Out_CreateOutput m_Out;
            } p6;

        } u;

    } s;

#ifdef STACK_CANARY
    PRINTF("@@ Stack available: %u\n", ((uint8_t*) &s) - ((uint8_t*) &_stack));
#endif // #ifdef STACK_CANARY

    memset(&s.u.hv, 0, sizeof(s.u.hv));
    memset(&s.kk1, 0, sizeof(s.kk1));
    Kdf_Init(&s.kk1.m_MasterKey, &s.u.hv);

    s.u.hv.m_pVal[0] = 4;
    memset(&s.kk2, 0, sizeof(s.kk2));
    Kdf_Init(&s.kk2.m_MasterKey, &s.u.hv);

    StackMark();

    s.u.p1.m_In.m_OpCode = g_Proto_Code_GetNumSlots;
    int n = KeyKeeper_InvokeExact(&s.kk1, (uint8_t*) &s.u.p2, sizeof(s.u.p2.m_In), sizeof(Proto_Out_TxAddCoins));

    StackPrint(&s, "GetNumSlots");

    PRINTF("NumSlots = %u, ret=%d\n", s.u.p1.m_Out.m_Value, n);

    memset(&s.u.p2, 0, sizeof(s.u.p2));
    s.u.p2.m_In.m_OpCode = g_Proto_Code_TxAddCoins;
    s.u.p2.m_In.m_Reset = 1;
    s.u.p2.m_In.m_Ins = 2;
    s.u.p2.m_In.m_Outs = 0;
    s.u.p2.m_In.m_InsShielded = 0;
    s.u.p2.m_pCid[0].m_Idx = 1;
    s.u.p2.m_pCid[0].m_Amount = 100;
    s.u.p2.m_pCid[0].m_AssetID = 18;
    s.u.p2.m_pCid[0].m_SubIdx = 3u << 24;
    s.u.p2.m_pCid[1].m_Idx = 2;
    s.u.p2.m_pCid[1].m_Amount = 8;
    s.u.p2.m_pCid[1].m_SubIdx = 3u << 24;

    StackMark();
    n = KeyKeeper_InvokeExact(&s.kk1, (uint8_t*) &s.u.p2, sizeof(s.u.p2), sizeof(Proto_Out_TxAddCoins));
    StackPrint(&s, "kk1 TxAddCoins");

    memset(&s.u.p2, 0, sizeof(s.u.p2));
    s.u.p2.m_In.m_OpCode = g_Proto_Code_TxAddCoins;
    s.u.p2.m_In.m_Reset = 1;
    s.u.p2.m_In.m_Ins = 0;
    s.u.p2.m_In.m_Outs = 2;
    s.u.p2.m_In.m_InsShielded = 0;
    s.u.p2.m_pCid[0].m_Idx = 1;
    s.u.p2.m_pCid[0].m_Amount = 70;
    s.u.p2.m_pCid[0].m_AssetID = 18;
    s.u.p2.m_pCid[0].m_SubIdx = 3u << 24;
    s.u.p2.m_pCid[1].m_Idx = 2;
    s.u.p2.m_pCid[1].m_Amount = 30;
    s.u.p2.m_pCid[1].m_AssetID = 18;
    s.u.p2.m_pCid[1].m_SubIdx = 3u << 24;

    StackMark();
    n = KeyKeeper_InvokeExact(&s.kk2, (uint8_t*) &s.u.p2, sizeof(s.u.p2), sizeof(Proto_Out_TxAddCoins));
    StackPrint(&s, "kk2 TxAddCoins");

    PRINTF("ret=%d\n", n);
    PRINTF("kk1.state=%d, kk1.beams=%d" "\n", (int) s.kk1.m_State, (int) s.kk1.u.m_TxBalance.m_RcvBeam);
    PRINTF("kk2.state=%d, kk2.beams=%d" "\n", (int) s.kk2.m_State, (int) s.kk2.u.m_TxBalance.m_RcvBeam);
    //    PRINTF("** Kk sizes = %u, %u, %u\n", sizeof(s.kk), sizeof(s.kk.m_MasterKey), sizeof(s.kk.u));
    //PRINTF("** Kk =  %.*H\n", sizeof(s.kk1), &s.kk1);

    s.u.p3.m_In.m_OpCode = g_Proto_Code_TxSend1;
    s.u.p3.m_In.m_Tx.m_Krn.m_Fee = 8;
    s.u.p3.m_In.m_Tx.m_Krn.m_hMin = 100500;
    s.u.p3.m_In.m_Tx.m_Krn.m_hMax = 100600;
    DeriveAddress2(&s.kk2, 102, &s.u.p3.m_In.m_Mut.m_Peer);
    s.u.p3.m_In.m_Mut.m_AddrID = 101;
    s.u.p3.m_In.m_iSlot = 2;

    StackMark();
    n = KeyKeeper_InvokeExact(&s.kk1, (uint8_t*) &s.u.p3, sizeof(s.u.p3.m_In), sizeof(s.u.p3.m_Out));
    StackPrint(&s, "TxSend1");
    PRINTF("ret=%d\n", n);
    Alert("TxSend1", n);

    s.m_TxAux.m_Comms = s.u.p3.m_Out.m_Comms;
    s.m_hvUserAggr = s.u.p3.m_Out.m_UserAgreement;

    s.u.p4.m_In.m_OpCode = g_Proto_Code_TxReceive;
    s.u.p4.m_In.m_Tx.m_Krn.m_Fee = 8;
    s.u.p4.m_In.m_Tx.m_Krn.m_hMin = 100500;
    s.u.p4.m_In.m_Tx.m_Krn.m_hMax = 100600;
    DeriveAddress2(&s.kk1, 101, &s.u.p4.m_In.m_Mut.m_Peer);

    s.u.p4.m_In.m_Mut.m_AddrID = 102;
    s.u.p4.m_In.m_Comms = s.m_TxAux.m_Comms;

    StackMark();
    n = KeyKeeper_InvokeExact(&s.kk2, (uint8_t*) &s.u.p4, sizeof(s.u.p4.m_In), sizeof(s.u.p4.m_Out));
    StackPrint(&s, "TxReceive");
    PRINTF("ret=%d\n", n);
    Alert("TxReceive", n);

    memmove(&s.u.p5.m_In.m_PaymentProof, &s.u.p4.m_Out.m_PaymentProof, sizeof(s.u.p5.m_In.m_PaymentProof));

    s.m_TxAux = s.u.p4.m_Out.m_Tx;

    s.u.p5.m_In.m_OpCode = g_Proto_Code_TxSend2;
    s.u.p5.m_In.m_Tx.m_Krn.m_Fee = 8;
    s.u.p5.m_In.m_Tx.m_Krn.m_hMin = 100500;
    s.u.p5.m_In.m_Tx.m_Krn.m_hMax = 100600;
    DeriveAddress2(&s.kk2, 102, &s.u.p5.m_In.m_Mut.m_Peer);
    s.u.p5.m_In.m_Mut.m_AddrID = 101;
    s.u.p5.m_In.m_iSlot = 2;
    s.u.p5.m_In.m_Comms = s.m_TxAux.m_Comms;
    s.u.p5.m_In.m_UserAgreement = s.m_hvUserAggr;

    StackMark();
    n = KeyKeeper_InvokeExact(&s.kk1, (uint8_t*) &s.u.p5, sizeof(s.u.p5.m_In), sizeof(s.u.p5.m_Out));
    StackPrint(&s, "TxSend2");
    PRINTF("ret=%d\n", n);
    Alert("TxSend2", n);

    memset(&s.u.p6, 0, sizeof(s.u.p6));
    s.u.p6.m_In.m_OpCode = g_Proto_Code_CreateOutput;
    s.u.p6.m_In.m_Cid.m_Amount = 400000;
    s.u.p6.m_In.m_Cid.m_Idx = 15;
    s.u.p6.m_In.m_Cid.m_Type = 0x22;
    s.u.p6.m_In.m_Cid.m_SubIdx = 8;
    s.u.p6.m_In.m_Cid.m_Amount = 4500000000ull;
    s.u.p6.m_In.m_Cid.m_AssetID = 0;

    StackMark();
    n = KeyKeeper_InvokeExact(&s.kk1, (uint8_t*)&s.u.p6, sizeof(s.u.p6.m_In), sizeof(s.u.p6.m_Out));
    StackPrint(&s, "CreateOutput");
    PRINTF("ret=%d\n", n);
    Alert("CreateOutput", n);
}

void BeamStackTest3()
{
    struct
    {
        KeyKeeper kk;

        union
        {
            UintBig hv;

            Proto_In_CreateShieldedVouchers reqVouchers;

            struct {
                Proto_Out_CreateShieldedVouchers m_Out;
                ShieldedVoucher m_Voucher;
            } resVouchers;

            struct {
                Proto_In_TxAddCoins m_Msg;
                ShieldedInput_Blob m_Blob;
                ShieldedInput_Fmt m_Fmt;
            } reqShieldedCoin;

            Proto_In_TxAddCoins m_Out_ShieldedCoin;
        } u;

    } s;

#ifdef STACK_CANARY
    PRINTF("@@ Stack available: %u\n", ((uint8_t*) &s) - ((uint8_t*) &_stack));
#endif // #ifdef STACK_CANARY

    memset(&s, 0, sizeof(s));
    memset(&s.kk, 0, sizeof(s.kk));
    Kdf_Init(&s.kk.m_MasterKey, &s.u.hv);


    StackMark();

    s.u.reqVouchers.m_OpCode = g_Proto_Code_CreateShieldedVouchers;
    s.u.reqVouchers.m_Count = 1;
    int n = KeyKeeper_InvokeExact(&s.kk, (uint8_t*) &s.u.reqVouchers, sizeof(s.u.reqVouchers), sizeof(s.u.resVouchers));

    StackPrint(&s, "CreateVouchers");

    PRINTF("CreateVouchers, ret=%d\n", n);

    memset(&s.u.reqShieldedCoin, 0, sizeof(s.u.reqShieldedCoin));

    s.u.reqShieldedCoin.m_Msg.m_OpCode = g_Proto_Code_TxAddCoins;
    s.u.reqShieldedCoin.m_Msg.m_Reset = 1;
    s.u.reqShieldedCoin.m_Msg.m_InsShielded = 1;

    s.u.reqShieldedCoin.m_Fmt.m_Amount = 9000000000ull;
    s.u.reqShieldedCoin.m_Fmt.m_AssetID = 14;
    s.u.reqShieldedCoin.m_Fmt.m_nViewerIdx = 2;

    StackMark();

    n = KeyKeeper_InvokeExact(&s.kk, (uint8_t*)&s.u.reqShieldedCoin, sizeof(s.u.reqShieldedCoin), sizeof(s.u.m_Out_ShieldedCoin));

    StackPrint(&s, "AddShieldedInput");

    PRINTF("AddShieldedInput, ret=%d\n", n);
}

void memcpy_unaligned(void* pDst, const void* pSrc, uint32_t n);

void BeamStackTest4()
{
    KeyKeeper* pKk = KeyKeeper_Get();
    memset(pKk, 0, sizeof(*pKk));

    UintBig hv;
    memset(hv.m_pVal, 0, sizeof(hv.m_pVal));
    Kdf_Init(&pKk->m_MasterKey, &hv);


#ifdef STACK_CANARY
    PRINTF("@@ Stack available: %u\n", ((uint8_t*) &hv) - ((uint8_t*) &_stack));
#endif // #ifdef STACK_CANARY

    // test CreateShieldedInput
    {
        Proto_In_CreateShieldedInput_1* pIn = (Proto_In_CreateShieldedInput_1*) G_io_apdu_buffer;
        memset(pIn, 0, sizeof(*pIn));
        pIn->m_OpCode = g_Proto_Code_CreateShieldedInput_1;

        {
            ShieldedInput_Fmt fmt;
            fmt.m_Amount = 43300;
            fmt.m_AssetID = 15;
            fmt.m_nViewerIdx = 443;

            memcpy_unaligned(&pIn->m_InpFmt, &fmt, sizeof(fmt));
        }

        {
            ShieldedInput_SpendParams sp;
            sp.m_hMin = 431000;
            sp.m_hMax = 432000;
            sp.m_WindowEnd = 4672342;
            sp.m_Sigma_M = 8;
            sp.m_Sigma_n = 4;

            memcpy_unaligned(&pIn->m_SpendParams, &sp, sizeof(sp));
        }

        Proto_Out_CreateShieldedInput_1* pOut = (Proto_Out_CreateShieldedInput_1*) G_io_apdu_buffer;

        StackMark();

        int n = KeyKeeper_InvokeExact(pKk, (uint8_t*) pIn, sizeof(*pIn), sizeof(*pOut));

        StackPrint(&hv, "CreateShieldedInput_1");

        PRINTF("CreateShieldedInput_1, ret=%d\n", n);
    }

    {
        Proto_In_CreateShieldedInput_2* pIn = (Proto_In_CreateShieldedInput_2*) G_io_apdu_buffer;
        memset(pIn, 0, sizeof(*pIn));
        pIn->m_OpCode = g_Proto_Code_CreateShieldedInput_2;

        Proto_Out_CreateShieldedInput_2* pOut = (Proto_Out_CreateShieldedInput_2*) G_io_apdu_buffer;

        StackMark();

        int n = KeyKeeper_InvokeExact(pKk, (uint8_t*) pIn, sizeof(*pIn), sizeof(*pOut));

        StackPrint(&hv, "CreateShieldedInput_2");

        PRINTF("CreateShieldedInput_2, ret=%d\n", n);
    }

    {
        Proto_In_CreateShieldedInput_3* pIn = (Proto_In_CreateShieldedInput_3*) G_io_apdu_buffer;
        memset(pIn, 0, sizeof(*pIn));
        pIn->m_OpCode = g_Proto_Code_CreateShieldedInput_3;

        Proto_Out_CreateShieldedInput_3* pOut = (Proto_Out_CreateShieldedInput_3*) G_io_apdu_buffer;

        StackMark();

        int n = KeyKeeper_InvokeExact(pKk, (uint8_t*) pIn, sizeof(*pIn) + sizeof(CompactPoint) * 8, sizeof(*pOut));

        StackPrint(&hv, "CreateShieldedInput_3");

        PRINTF("CreateShieldedInput_3, ret=%d\n", n);
    }

}

void BeamStackTest5()
{
    Alert("gens", (uint32_t) Context_get());

    KeyKeeper* pKk = KeyKeeper_Get();
    memset(pKk, 0, sizeof(*pKk));

    UintBig hv;
    memset(hv.m_pVal, 0, sizeof(hv.m_pVal));
    Kdf_Init(&pKk->m_MasterKey, &hv);

    Alert("Kk inited", 0);


#ifdef STACK_CANARY
    PRINTF("@@ Stack available: %u\n", ((uint8_t*) &hv) - ((uint8_t*) &_stack));
    Alert("Stack avail", ((uint8_t*) &hv) - ((uint8_t*) &_stack));
#endif // #ifdef STACK_CANARY




/*
    static const uint8_t pMsg0[] = { 0x18,0x01,0x02,0x01,0x01,0xd4,0xa5,0x50,0xe1,0x1e,0x46,0x0b,0x69,0x6d,0x72,0x6f,0x6e,0x00,0x00,0x00,0x03,0xe0,0xc8,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x5c,0x61,0x2f,0x07,0xf3,0x33,0xb1,0xd2,0x6d,0x72,0x6f,0x6e,0x00,0x00,0x00,0x03,0x30,0x88,0x01,0x00,0x00,0x00,0x00,0x00,0x78,0x56,0x34,0x12,0xb3,0x85,0x39,0x79,0xd6,0xd6,0xff,0xc8,0x6d,0x72,0x6f,0x6e,0x00,0x00,0x00,0x03,0x64,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x26,0xae,0x16,0xb0,0x47,0x64,0xa5,0x6d,0xcc,0xd9,0x05,0x9d,0x2c,0x02,0x8f,0xa1,0xc2,0x18,0xb3,0xae,0x2e,0x16,0xcc,0x45,0xd1,0xe2,0x27,0xa3,0xdb,0x12,0x41,0x41,0x81,0x6e,0x12,0xd7,0xc8,0x24,0xea,0xe2,0x19,0x7f,0x9a,0xbb,0x17,0x31,0x4b,0x07,0xa6,0x14,0x77,0x6e,0x89,0xc1,0x7e,0xb7,0x5a,0x9a,0xd9,0xd6,0x7f,0x5c,0xce,0xdb,0x9a,0xa9,0x04,0x8c,0xf3,0x34,0xfd,0xd9,0xe3,0xfd,0xc3,0x95,0xd7,0x23,0x52,0x93,0x9a,0xaf,0x47,0x43,0xd7,0x29,0xa4,0x14,0x4d,0x74,0x28,0x50,0x37,0x0e,0x31,0xfd,0x0f,0x3c,0xb5,0xf9,0x68,0x89,0x4f,0x9c,0x49,0xbb,0xa4,0x92,0x38,0xb4,0x28,0x2e,0x03,0xf8,0xd1,0xbf,0x70,0xda,0x03,0x28,0xd7,0x6e,0x5c,0x6a,0x82,0x6c,0x1c,0xba,0x00,0x90,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x2c,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xb0,0x16,0xae,0x26 };
    static const uint8_t pMsg1[] = { 0x28,0x00,0x00,0xe6,0x00,0x4b,0x16,0x93,0x57,0xd4,0x62,0x7c,0x8e,0xd7,0xc8,0x57,0xce,0x1d,0x99,0xf1,0xcf,0xe3,0xdb,0x1f,0xbb,0xc1,0x86,0x5c,0xc7,0x79,0x8a,0x87,0x97,0x1e,0x89,0x4e,0x2c,0x39,0xb2,0xc1,0x4b,0xf9,0x19,0x22,0x1c,0xdb,0x8c,0x53,0x97,0x2d,0xd2,0x46,0x8b,0x33,0xb0,0x2e,0x5c,0x80,0x7c,0xc7,0x34,0x75,0xd0,0x4e,0x25,0x3a,0x64,0x8d,0x06,0x9d,0x60,0x3c,0x5f,0x27,0xfa,0xed,0xdc,0x2a,0xaa,0xaf,0x81,0xa0,0xa5,0xca,0xf2,0xe2,0xaf,0xea,0x94,0xb9,0x26,0xf6,0x47,0xeb,0x64,0xd3,0xe5,0x81,0x9d,0xb1,0xbf,0x1f,0xa9,0xfb,0x04,0x5a,0x9c,0xc3,0x8e,0x2c,0xc5,0x67,0x7c,0xb8,0x90,0xd2,0x22,0xa0,0x3c,0xad,0x8e,0x43,0x86,0xd6,0xf1,0x1b,0xc7,0x5c,0x33,0x54,0x37,0xa6,0x42,0x21,0x8b,0xff,0xa9,0xe7,0x0d,0x72,0xb6,0x0a,0x8f,0x55,0x75,0x58,0xe9,0x3e,0x5e,0x7d,0x1b,0x7a,0xbe,0x55,0xcc,0x91,0x82,0x9b,0x3c,0xdb,0x92,0x56,0xfb,0x7d,0xc7,0x80,0x59,0x94,0x3c,0x32,0x4c,0xb7,0x19,0x89,0xce,0xa0,0x7b,0x45,0x53,0xb6,0x41,0x23,0x69,0x9e,0x9f,0xe6,0x36,0xa1,0x21,0x87,0x36,0x9f,0x69,0x35,0xef,0x8a,0x28,0x53,0x08,0xd2,0x2e,0x96,0x90,0x22,0x28,0x44,0xba,0x54,0x6e,0xd8,0xfa,0x5c,0x8f,0x20,0xa0,0xdf,0x95,0x1c,0x74,0x11,0x62,0xa9,0x3e,0xa6,0xcb,0xe5,0x49,0x9a,0x4b,0xd0,0x10,0x10,0xb1,0x30,0x6e };
    static const uint8_t pMsg2[] = { 0x28,0xe6,0x00,0xe6,0x00,0x2f,0x56,0x7e,0x46,0x0f,0x2d,0xd7,0x87,0xd8,0xd2,0x21,0xfd,0x2b,0x25,0x11,0xeb,0x55,0xff,0x4e,0xee,0xa7,0x9c,0x54,0xac,0xe2,0x87,0x9d,0xe1,0x92,0x82,0x1f,0x4a,0xed,0xab,0x8d,0xdf,0xd5,0xc1,0x87,0x2a,0x83,0xe9,0x47,0x82,0x2a,0xf1,0x17,0x50,0xa7,0x59,0x3b,0x3e,0xa7,0xf0,0x29,0xee,0xfd,0x03,0xc4,0x4d,0x37,0x63,0x2a,0xed,0xd4,0xcf,0x3d,0x76,0x84,0xfa,0xdf,0x4a,0xa8,0xde,0x86,0xf6,0xa7,0x2d,0x36,0xfc,0x55,0x15,0xe9,0x8a,0xc6,0xcb,0x92,0xdb,0x33,0x79,0xb7,0x73,0x49,0xf5,0x31,0x35,0xb2,0xcf,0xb4,0xe0,0x99,0x64,0x75,0xf9,0xba,0xc8,0x7d,0x62,0x2b,0x0b,0xf0,0xf5,0xf3,0xee,0x23,0x53,0x12,0xd8,0xe5,0xf3,0xf4,0xda,0x20,0x14,0x50,0x08,0x06,0x73,0xb0,0x28,0x41,0xf4,0xc6,0xb3,0x1f,0x56,0x1d,0x2d,0x59,0xfb,0x78,0x39,0x39,0xa5,0x29,0x26,0xf0,0xc9,0x37,0xff,0x6f,0x4f,0x25,0xc0,0xbc,0x6a,0x55,0x11,0x27,0xfa,0x57,0xd7,0x5d,0x8d,0x90,0xe4,0x89,0x66,0xbf,0x93,0x41,0xc2,0xdc,0xfb,0xbf,0xfe,0x4c,0x55,0x0d,0xbf,0x79,0xd3,0xb8,0x30,0x1f,0x19,0xde,0xa1,0x55,0x2e,0x8d,0x6d,0xcf,0x95,0x18,0x77,0x7b,0x2b,0x3f,0x69,0x55,0xa8,0x76,0x30,0xcd,0xa9,0xc2,0xc9,0x0c,0x39,0x50,0xe1,0x27,0x55,0x60,0xd5,0x2c,0xb0,0xf8,0xc4,0x9e,0x4a,0xc7,0x5c,0x7d,0x7c,0xd9,0xd3,0xc6,0x44 };
    static const uint8_t pMsg3[] = { 0x28,0xcc,0x01,0xe6,0x00,0x32,0x7e,0x99,0x44,0xb0,0xe7,0xe8,0xc6,0xe3,0x2a,0x1e,0xae,0x0d,0xf3,0xb3,0xa6,0x65,0x01,0x47,0x93,0xc5,0xe7,0xe1,0x37,0xb5,0xfd,0x58,0xa4,0x1d,0xa9,0xe3,0xae,0xee,0xf3,0xd4,0x68,0x85,0x1e,0xb2,0xd6,0xd5,0xfe,0xb7,0x43,0xe5,0x40,0x89,0x4a,0x3a,0x63,0x8c,0xd8,0xeb,0x9b,0x9b,0xaf,0xb4,0x20,0x24,0x80,0x94,0xe0,0x6c,0x2b,0x4f,0xb5,0x3a,0x1e,0x0c,0xbb,0xdc,0xa2,0xe1,0x80,0x5b,0xac,0xaa,0x8f,0x3a,0xea,0x62,0xd9,0x95,0xea,0xfc,0x6a,0xf8,0xa5,0x23,0x4f,0x4d,0x29,0x49,0xed,0x91,0xd1,0xc0,0xdb,0x8e,0xa8,0x44,0xbe,0x52,0x94,0xb8,0x78,0xe5,0x74,0xb3,0x74,0x4d,0x2e,0x34,0x47,0xc0,0x51,0x2c,0xfc,0x05,0x04,0x0a,0x10,0x07,0x96,0x18,0x4b,0x97,0x6c,0x6b,0x6c,0xec,0xad,0x01,0x35,0xfa,0x69,0x49,0x0b,0xf6,0xe4,0x21,0xc7,0xb9,0x66,0x15,0x26,0x7d,0x99,0x9c,0x73,0x7a,0x07,0x02,0xe7,0x7b,0xed,0x30,0xb5,0xca,0x27,0xa7,0x03,0x42,0x21,0xa4,0xe1,0x47,0x14,0x8f,0xa7,0x3a,0x01,0x2a,0xe9,0x90,0xef,0x2b,0xa9,0xa7,0xa7,0x03,0x51,0x4d,0x8c,0x21,0x2e,0xe1,0xe6,0xd4,0xf3,0x99,0x12,0x48,0x8c,0x48,0xab,0x26,0xd8,0x7c,0x8c,0xbe,0xa0,0x13,0x8f,0x86,0xff,0xee,0xce,0xbe,0x84,0xab,0xb9,0xcd,0xea,0x7b,0xcd,0x69,0x6c,0x0d,0x5d,0x5a,0x93,0xb4,0xfc,0x85,0x32,0x1c,0x79,0x82,0x35 };
    static const uint8_t pMsg4[] = { 0x28,0xb2,0x02,0xe6,0x00,0x8a,0x63,0x0e,0xc8,0x0e,0x72,0xca,0xff,0x6c,0xaa,0xbf,0x00,0x4b,0x96,0xa8,0x19,0x01,0xa6,0xdf,0xff,0x5d,0x69,0xb9,0xd4,0xd9,0x0c,0xba,0x71,0xee,0xcd,0xab,0x89,0x11,0x3b,0xbf,0x20,0x53,0xb9,0x4f,0xbc,0x0e,0xe0,0xc5,0xf7,0xa3,0x6c,0x5f,0x80,0x5c,0x01,0x14,0x83,0xa3,0xad,0x64,0x29,0x50,0xbc,0xf1,0x64,0x3c,0x20,0x01,0xb0,0x5a,0xee,0x85,0x4b,0x57,0xd8,0x1f,0x01,0x99,0xd9,0xd9,0xce,0x2e,0xfa,0x6b,0x13,0x26,0x6f,0x87,0x7b,0x8f,0x9a,0xfa,0x37,0xdf,0xaf,0x5f,0xec,0x7b,0xfe,0xad,0x55,0x6c,0xdb,0xc9,0xec,0x8f,0xf0,0xa4,0x02,0x59,0xd8,0x37,0x06,0xf3,0x9f,0x6e,0xce,0x2c,0x52,0x7d,0x10,0x45,0x18,0xdb,0x67,0xd8,0x54,0x4a,0x85,0xc5,0x5d,0x26,0x12,0x8f,0xe9,0x2a,0xb6,0x1d,0xfb,0xf5,0x71,0x54,0x22,0xdc,0x70,0x4f,0x3d,0xd1,0x80,0x6c,0x2d,0x0d,0x4b,0xd5,0x8d,0xa8,0xdc,0x3d,0x9b,0x87,0xbb,0xf8,0xc2,0xb2,0x41,0x46,0x9d,0x55,0xcc,0xbc,0x31,0xea,0x8a,0xf1,0x6a,0xc2,0x7f,0x70,0x71,0xc5,0x14,0x16,0xdf,0x01,0x44,0xe5,0x70,0x13,0x81,0xf7,0xb6,0x4d,0xda,0xc4,0xb5,0x4c,0xd2,0x97,0x77,0x5a,0xd9,0xaf,0xc8,0xf1,0x94,0xd3,0x8e,0xb0,0xfa,0x88,0x6c,0xed,0xfb,0xf5,0x45,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 };
    static const uint8_t pMsg5[] = { 0x28,0x98,0x03,0x0e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 };
    static const uint8_t pMsg6[] = { 0x36,0xe0,0xc8,0x10,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x2b,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0x02,0x32,0xd7,0xa8,0x40,0xd8,0xb9,0x5a,0x20,0xfa,0xe8,0xe6,0xbb,0x19,0x7e,0xa7,0x67,0x86,0xd9,0x91,0xf3,0x1f,0x6a,0x77,0x14,0x78,0xcc,0x85,0x69,0x18,0xd6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x39,0x9c,0x98,0xda,0xd1,0xe0,0xbb,0x45,0xef,0x96,0x46,0xe0,0xce,0x3c,0x87,0xab,0xf9,0xd0,0xc2,0x00,0xbd,0x15,0x5e,0x7b,0x7a,0x8d,0x6c,0x17,0x92,0x93,0x92,0xa1,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf4,0x8f,0xa0,0x81,0x89,0xc3,0xd5,0xc9,0x37,0x39,0x0c,0x18,0x2d,0xf7,0xee,0x9a,0x01,0xbe,0x0d,0xca,0x35,0x99,0x60,0x7c,0xc1,0x02,0x06,0x37,0x45,0xde,0xdb,0xcf,0x2c,0x26,0x57,0xcf,0x58,0xa7,0x3c,0xdd,0xc4,0xb9,0x16,0x62,0x77,0x62,0x66,0x8e,0x90,0xf4,0xaa,0x68,0xdd,0x01,0xa4,0xd3,0xd8,0x1b,0xff,0xec,0x80,0x0b,0x4c,0xeb,0xa0,0x01,0x00,0x00 };
*/

    static const uint8_t pMsg0[] = { 0x18,0x01,0x02,0x01,0x01,0x06,0xe4,0x52,0xb1,0xce,0x54,0x9d,0xaa,0x6d,0x72,0x6f,0x6e,0x00,0x00,0x00,0x03,0xe0,0xc8,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xf5,0x0e,0x5d,0x88,0x33,0x08,0x5f,0x6d,0x72,0x6f,0x6e,0x00,0x00,0x00,0x03,0x30,0x88,0x01,0x00,0x00,0x00,0x00,0x00,0x78,0x56,0x34,0x12,0xd6,0xb6,0xea,0x68,0x2a,0x96,0x23,0x5e,0x6d,0x72,0x6f,0x6e,0x00,0x00,0x00,0x03,0x64,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x4c,0xc6,0x4d,0x16,0xed,0x2a,0x39,0x89,0x10,0x44,0x2c,0xca,0xfc,0x86,0xcb,0x84,0xfa,0x7d,0x9f,0x39,0x01,0xa0,0x0e,0x61,0x49,0xaf,0x8a,0x0d,0xd6,0x29,0xa7,0x66,0xa5,0x6b,0xde,0x73,0x32,0x2b,0x93,0x54,0xdf,0xb8,0x97,0x3b,0x74,0x26,0x9f,0xc0,0x29,0xc0,0x1c,0x0b,0x29,0x55,0x5c,0xb7,0x80,0xda,0x1b,0x22,0x84,0x52,0x38,0xaa,0x69,0x81,0xcc,0x95,0x25,0x53,0x6c,0x6c,0x5d,0x23,0x01,0xa0,0xe3,0x73,0x9a,0x88,0x0e,0x71,0x8f,0xb1,0xbb,0x6f,0x47,0xe0,0x5b,0xbb,0xf5,0x0a,0x8d,0x82,0xcd,0x5c,0x61,0x68,0x82,0x5f,0xae,0x85,0x32,0xa0,0x65,0xe4,0xf2,0x2e,0xcf,0x6d,0xa8,0x10,0x3f,0x24,0x86,0x55,0x81,0xd7,0x82,0xdf,0xf5,0xf5,0x1b,0xd6,0x87,0x82,0x21,0x61,0x00,0x90,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x2c,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x16,0x4d,0xc6,0x4c };
    static const uint8_t pMsg1[] = { 0x28,0x00,0x00,0xe6,0x00,0x4c,0x23,0x6c,0xd0,0x76,0xa0,0x98,0xbf,0xff,0x94,0x54,0x1c,0xa6,0xa5,0x9b,0x35,0xc0,0x4d,0xb4,0x39,0xb8,0x40,0xe8,0xd6,0xc0,0xc1,0x6f,0x61,0x72,0xdd,0xf9,0x7d,0xc5,0x06,0x47,0x64,0xe1,0x13,0x29,0x86,0xe2,0xf3,0xee,0xdb,0xa8,0xab,0xbc,0x12,0x34,0x19,0xdb,0x34,0x9e,0x77,0x7a,0xed,0x0a,0xec,0xbb,0x06,0x5c,0xed,0x85,0xa6,0xff,0x69,0x6b,0x8c,0xb4,0x05,0xdb,0x9f,0x64,0x76,0x8d,0xd8,0x86,0xf9,0x3c,0xea,0xf8,0x99,0x0c,0x9b,0x30,0xaa,0x6a,0x28,0x39,0x74,0xd9,0x8a,0x9e,0x64,0x77,0x52,0xdf,0xa6,0x7a,0x4b,0x56,0x55,0x35,0x48,0x0d,0xfc,0x60,0xbd,0xfa,0x7d,0x34,0x12,0xd8,0xfb,0x8e,0x24,0x0d,0x71,0xfb,0xbf,0x2c,0x33,0x4a,0x30,0x51,0x5c,0x29,0x90,0xd6,0xb3,0xb2,0xfb,0x03,0xe5,0x3c,0x7a,0xb5,0x14,0xce,0x49,0x54,0x2d,0x1e,0x1a,0x6c,0x96,0xab,0xc0,0x88,0xbe,0xa5,0x70,0xac,0xb2,0xa8,0xe9,0xcd,0xdb,0x57,0x14,0x5d,0x19,0x04,0x7d,0x43,0x7d,0x73,0x7e,0x76,0xa7,0x36,0x3e,0x76,0x3a,0xc9,0x6d,0x6d,0xfb,0x5d,0x94,0x8a,0x8e,0x37,0xa9,0x32,0x1b,0xab,0x3e,0x99,0x49,0x51,0x9f,0x7d,0xf8,0x06,0x7d,0xa7,0xee,0x86,0xa7,0x09,0x16,0x3b,0x68,0xce,0xf3,0xa1,0xd0,0x22,0x7c,0x15,0x42,0x91,0x67,0xd1,0xd6,0x1a,0xe0,0x87,0xd2,0x57,0x42,0x87,0x9c,0x4d,0xdb,0xb2,0x64,0x2e,0x52 };
    static const uint8_t pMsg2[] = { 0x28,0xe6,0x00,0xe6,0x00,0x28,0x7a,0x49,0xad,0x2e,0x67,0xdb,0x8c,0xa7,0xb4,0x8f,0x51,0x1e,0x6b,0x48,0x99,0x18,0xd7,0x2e,0x0e,0xaa,0xb2,0x46,0xe1,0x50,0x71,0x4b,0xaa,0xc2,0xda,0x36,0xf2,0x3a,0x13,0x96,0x45,0x84,0xc3,0x16,0x6a,0x49,0xc9,0xec,0x7e,0xc5,0xba,0xdb,0x71,0x7a,0x02,0x8b,0x1c,0x2f,0x07,0x35,0xae,0x9b,0x4e,0x62,0xa5,0xdd,0x21,0x97,0xfb,0x44,0x0b,0x16,0x91,0xf6,0x1f,0x77,0xd3,0x14,0xf7,0xdc,0x9c,0xa2,0x5c,0x46,0x86,0x18,0x31,0x13,0x83,0xa1,0x5d,0x65,0x99,0x09,0xbc,0x5c,0x69,0x07,0xd7,0xce,0xd0,0x40,0x28,0xcb,0x2f,0xfe,0xb2,0x09,0x24,0x5e,0x3e,0x16,0x81,0xbf,0x35,0xc1,0x02,0xd9,0xb3,0x6e,0x66,0x61,0x46,0x9d,0x66,0x75,0x1f,0xe8,0x1f,0x07,0xa0,0x29,0x14,0xdc,0x70,0x92,0x3c,0xff,0xe0,0x3c,0x98,0xdc,0x01,0x93,0xba,0x87,0x59,0x59,0x94,0xcd,0x06,0x36,0xb3,0xc7,0xfb,0x37,0xea,0x0d,0xc9,0x5e,0x3b,0x0c,0x0a,0x56,0x99,0x23,0xe8,0x8b,0xf4,0x82,0xa8,0xe3,0x1f,0xf6,0x4f,0x1f,0x7c,0x1f,0x4f,0x42,0x56,0xf0,0x01,0xbc,0x59,0x5f,0xd7,0x1b,0x33,0x49,0xf5,0xa7,0xa2,0xc4,0x0f,0x5c,0x20,0x87,0x86,0x3a,0xd1,0xf2,0x5a,0xb6,0x5a,0x9a,0xc4,0x85,0xfe,0x66,0xeb,0x74,0x19,0x63,0x21,0xd6,0xb4,0x1a,0x3e,0x4f,0x6d,0x81,0xa3,0xed,0xc0,0x69,0x89,0x94,0x0a,0xa8,0x58,0x2b,0xa7,0x15,0x86 };
    static const uint8_t pMsg3[] = { 0x28,0xcc,0x01,0xe6,0x00,0x34,0x18,0xad,0xb9,0x73,0xc7,0xbb,0x12,0xc7,0x23,0x0f,0x39,0x95,0xaa,0x7e,0x49,0x74,0x61,0x4e,0x16,0x42,0x33,0x30,0x11,0x4f,0x34,0x6f,0xdb,0x95,0x89,0xdc,0x99,0x67,0xce,0x7e,0x0c,0xff,0x12,0x89,0x8e,0x5b,0x7d,0x7c,0xc3,0xfc,0xba,0xf4,0x9a,0xb8,0xf7,0xd3,0xf8,0x8d,0x49,0xc9,0x5b,0xb4,0x60,0xde,0x04,0x9f,0x3c,0xfb,0xdc,0x7a,0x0c,0xb1,0x4d,0x0f,0x0e,0x0a,0x88,0x92,0xf9,0x0a,0x02,0xa9,0x8c,0x63,0xc5,0x87,0xff,0xdf,0x93,0x6a,0xef,0xaa,0xcd,0x89,0x71,0x6a,0xb9,0x17,0xf3,0x5f,0xa3,0xc3,0x52,0xd0,0x72,0xa9,0x8f,0xea,0x4f,0x53,0xc2,0xed,0xb0,0xb6,0xdc,0x0a,0x9c,0xf8,0xda,0xe0,0x2c,0x43,0x13,0xb4,0xd5,0x16,0xb9,0x49,0x8d,0x7d,0x98,0xb4,0xc8,0x30,0x7a,0xb6,0x07,0xcf,0xa6,0xa4,0x62,0x63,0x2e,0xb3,0xef,0x25,0xbe,0x9d,0x46,0xd2,0x91,0x2c,0x5e,0xbb,0x8b,0x34,0xce,0xb9,0x2f,0x78,0xaa,0x03,0x2d,0xc1,0x12,0x55,0x44,0xb0,0x8b,0x51,0x2f,0x51,0xa9,0x1e,0x82,0x6b,0x2e,0xd3,0xba,0x4b,0x4f,0x64,0xc1,0x6b,0x1a,0x32,0xa0,0xcf,0x92,0xd4,0xda,0xd9,0x74,0x7a,0x4e,0x89,0x63,0xe5,0xba,0xc8,0x31,0xfd,0x7b,0x7d,0xe3,0x7c,0x04,0x06,0xb9,0x00,0x31,0x33,0x7c,0x2d,0xa2,0x1b,0x94,0x2b,0x14,0x81,0xa4,0xcd,0x7f,0xca,0x42,0x38,0x55,0xce,0x72,0xf7,0x96,0xf0,0x29,0xbf,0x90 };
    static const uint8_t pMsg4[] = { 0x28,0xb2,0x02,0xe6,0x00,0xdb,0x15,0xea,0x81,0x33,0x86,0xc5,0xf7,0x6a,0xd8,0x71,0xf6,0x37,0xb9,0x06,0x80,0xfa,0xe7,0xd5,0x86,0x32,0xce,0x23,0x2f,0x29,0x78,0xef,0x4d,0xbd,0x09,0x1f,0x6f,0x95,0xdd,0xd8,0x4c,0xbb,0x34,0xda,0xef,0xaa,0x42,0x27,0xee,0x1d,0x06,0xca,0x5a,0x01,0x61,0xc1,0xcf,0xb7,0x3e,0x8f,0x29,0x8d,0x9b,0xec,0x47,0x2e,0x17,0xf3,0x07,0xa1,0x70,0xa4,0x6c,0xa0,0xad,0x9f,0x28,0xbf,0xe3,0xec,0x92,0x44,0x34,0xaa,0x2a,0x0c,0x01,0x05,0x78,0x84,0x81,0x29,0x74,0x1d,0x6e,0x52,0xb8,0x5b,0xd7,0xe1,0x08,0x75,0x51,0x29,0x5e,0x65,0xd6,0x2c,0x07,0x02,0x2b,0x97,0x6a,0x0a,0xce,0xf7,0x9b,0x98,0x96,0x94,0x97,0xc5,0x2c,0x53,0x5a,0x57,0x29,0xdb,0xe4,0xfd,0xd5,0x58,0x8f,0xf7,0xa7,0x7f,0x0e,0x6b,0x3c,0xa2,0x45,0x6e,0x15,0x33,0x95,0x54,0xa1,0x37,0xa1,0xd8,0xc6,0x01,0xd4,0x88,0xa4,0xca,0x26,0x11,0x8f,0xd7,0xb0,0x2c,0xee,0xfd,0x03,0x5e,0x54,0x7b,0x04,0xc5,0xfd,0xd1,0xb8,0xdf,0x76,0x84,0x6d,0x0d,0x2b,0x30,0x18,0x15,0x1b,0xf5,0x00,0xc5,0xf4,0x60,0xda,0xfa,0x2a,0xeb,0x35,0x7a,0x63,0x0c,0x1a,0x03,0x66,0x09,0x0b,0x50,0x2c,0x8f,0x63,0x56,0xd2,0x9c,0xf9,0x0e,0x80,0xed,0x40,0x3c,0xb0,0xe6,0xdd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd };
    static const uint8_t pMsg5[] = { 0x28,0x98,0x03,0x0e,0x00,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd };
    static const uint8_t pMsg6[] = { 0x36,0xe0,0xc8,0x10,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x2b,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0x02,0x32,0xd7,0xa8,0x40,0xd8,0xb9,0x5a,0x20,0xfa,0xe8,0xe6,0xbb,0x19,0x7e,0xa7,0x67,0x86,0xd9,0x91,0xf3,0x1f,0x6a,0x77,0x14,0x78,0xcc,0x85,0x69,0x18,0xd6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xba,0x06,0xbb,0x98,0x85,0x80,0x1d,0x0b,0x90,0x49,0xd5,0x25,0x09,0xd0,0x70,0xfe,0x0e,0xa6,0x5e,0x0a,0xc1,0xbb,0x97,0xa0,0xc4,0x88,0x17,0x13,0x6d,0xe6,0x60,0xfd,0x88,0x99,0x97,0xec,0xf7,0x42,0xd5,0xa1,0x2e,0x9d,0x52,0xd4,0x15,0x5e,0x39,0xe9,0x93,0x41,0x89,0x1d,0x9e,0xe8,0x44,0xa7,0x66,0x7c,0x64,0xcc,0xe0,0x0f,0xd7,0xf3,0x5b,0x1d,0x62,0x54,0x91,0x7b,0x9e,0xb2,0x16,0x4b,0x6b,0x80,0xe4,0x94,0x0c,0x32,0x4a,0x4e,0xe7,0x55,0x7a,0xfd,0x19,0x12,0xc5,0x96,0x8b,0x66,0x37,0x42,0x6d,0x8f,0x77,0x9a,0xc2,0x63,0xee,0xd4,0xe7,0x65,0x31,0xf3,0x50,0x27,0xba,0x08,0x54,0x48,0x78,0x11,0xad,0x98,0x11,0xd2,0x3a,0x63,0xf2,0xaf,0x98,0xb3,0xd6,0x18,0x2d,0x76,0x01,0x01,0x00 };

    StackMark();

    uint32_t nOut = sizeof(G_io_apdu_buffer);
    int n = KeyKeeper_Invoke(pKk, pMsg0, sizeof(pMsg0), G_io_apdu_buffer, &nOut);

    StackPrint(&hv, "SendShielded_0");
    PRINTF("SendShielded_0, ret=%d, size=%d\n", n, nOut);
    Alert("SendShielded_0", n);

    StackMark();

    nOut = sizeof(G_io_apdu_buffer);
    n = KeyKeeper_Invoke(pKk, pMsg1, sizeof(pMsg1), G_io_apdu_buffer, &nOut);

    StackPrint(&hv, "SendShielded_1");
    PRINTF("SendShielded_1, ret=%d, size=%d\n", n, nOut);
    Alert("SendShielded_1", n);

    StackMark();

    nOut = sizeof(G_io_apdu_buffer);
    n = KeyKeeper_Invoke(pKk, pMsg2, sizeof(pMsg2), G_io_apdu_buffer, &nOut);

    StackPrint(&hv, "SendShielded_2");
    PRINTF("SendShielded_2, ret=%d, size=%d\n", n, nOut);
    Alert("SendShielded_2", n);

    StackMark();

    nOut = sizeof(G_io_apdu_buffer);
    n = KeyKeeper_Invoke(pKk, pMsg3, sizeof(pMsg3), G_io_apdu_buffer, &nOut);

    StackPrint(&hv, "SendShielded_3");
    PRINTF("SendShielded_3, ret=%d, size=%d\n", n, nOut);
    Alert("SendShielded_3", n);

    StackMark();

    nOut = sizeof(G_io_apdu_buffer);
    n = KeyKeeper_Invoke(pKk, pMsg4, sizeof(pMsg4), G_io_apdu_buffer, &nOut);

    StackPrint(&hv, "SendShielded_4");
    PRINTF("SendShielded_4, ret=%d, size=%d\n", n, nOut);
    Alert("SendShielded_4", n);

    StackMark();

    nOut = sizeof(G_io_apdu_buffer);
    n = KeyKeeper_Invoke(pKk, pMsg5, sizeof(pMsg5), G_io_apdu_buffer, &nOut);

    StackPrint(&hv, "SendShielded_5");
    PRINTF("SendShielded_5, ret=%d, Data=%.*H\n", n, nOut, G_io_apdu_buffer);
    Alert("SendShielded_5", n);

    StackMark();

    nOut = sizeof(G_io_apdu_buffer);
    n = KeyKeeper_Invoke(pKk, pMsg6, sizeof(pMsg6), G_io_apdu_buffer, &nOut);

    StackPrint(&hv, "SendShielded_6");
    PRINTF("SendShielded_6, ret=%d, Data=%.*H\n", n, nOut, G_io_apdu_buffer);
    Alert("SendShielded_6", n);
}

bool VerifyStatus(cx_err_t errCode, const char* szName)
{
    if (!errCode)
        return true;

    Alert(szName, errCode);
    return false;
}

#define VERIFY_STATUS(expr) VerifyStatus(expr, #expr)

void BeamPerfTest()
{
    if (VERIFY_STATUS(cx_bn_lock(CX_BN_WORD_ALIGNEMENT, 0)))
    {

        cx_ecpoint_t pt1, pt2;
        if (VERIFY_STATUS(cx_ecpoint_alloc(&pt1, CX_CURVE_SECP256K1)))
        {
            if (VERIFY_STATUS(cx_ecpoint_alloc(&pt2, CX_CURVE_SECP256K1)))
            {
                static const uint8_t x[32] = { 0x79, 0xBE, 0x66, 0x7E, 0xF9, 0xDC, 0xBB, 0xAC, 0x55, 0xA0, 0x62, 0x95, 0xCE, 0x87, 0x0B, 0x07, 0x02, 0x9B, 0xFC, 0xDB, 0x2D, 0xCE, 0x28, 0xD9, 0x59, 0xF2, 0x81, 0x5B, 0x16, 0xF8, 0x17, 0x98 };
                static const uint8_t y[32] = { 0x48, 0x3A, 0xDA, 0x77, 0x26, 0xA3, 0xC4, 0x65, 0x5D, 0xA4, 0xFB, 0xFC, 0x0E, 0x11, 0x08, 0xA8, 0xFD, 0x17, 0xB4, 0x48, 0xA6, 0x85, 0x54, 0x19, 0x9C, 0x47, 0xD0, 0x8F, 0xFB, 0x10, 0xD4, 0xB8 };

                if (VERIFY_STATUS(cx_ecpoint_init(&pt1, x, sizeof(x), y, sizeof(y))) && VERIFY_STATUS(cx_ecpoint_init(&pt2, x, sizeof(x), y, sizeof(y))))
                {
                    Alert("Mul1x100", 0);

                    static const uint8_t pS1[] = { 0x77,0x03,0x8b,0x81,0x0c,0x1f,0x76,0x54,0xa8,0xda,0x42,0x8a,0x9c,0xd0,0x04,0x1c,0x22,0x11,0x64,0x6d,0x3a,0xd1,0xac,0xa3,0x34,0x31,0x76,0x8f,0x24,0x18,0x2d,0xa6 };
                    static const uint8_t pS2[] = { 0xe0,0x84,0xa2,0x7d,0x3b,0xd6,0x75,0xf3,0xe2,0xca,0x05,0x6d,0x1b,0x5b,0x67,0xd6,0x6e,0xbd,0x05,0x45,0x0d,0xb8,0x04,0xd1,0x6d,0xef,0x6f,0xb1,0xe9,0x09,0xbc,0xc8 };
                    static const uint8_t pS3[] = { 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xBA,0xAE,0xDC,0xE6,0xAF,0x48,0xA0,0x3B,0xBF,0xD2,0x5E,0x8C,0xD0,0x36,0x41,0x41 };

                    for (int i = 0; i < 100; ++i)
                    {
                        if (!VERIFY_STATUS(cx_ecpoint_scalarmul(&pt1, pS1, sizeof(pS1))))
                            break;
                    }

                    Alert("Mul1x100", 1);

                    Alert("Mul2x100", 0);

                    for (int i = 0; i < 100; ++i)
                    {
                        if (!VERIFY_STATUS(cx_ecpoint_double_scalarmul(&pt1, &pt1, &pt2, pS1, sizeof(pS1), pS2, sizeof(pS2))))
                            break;
                    }

                    Alert("Mul2x100", 1);

                    cx_bn_t f0=0, f1=0, f2=0, fMod = 0;
                    VERIFY_STATUS(cx_bn_alloc(&f0, sizeof(pS1)));
                    VERIFY_STATUS(cx_bn_alloc_init(&f1, sizeof(pS1), pS1, sizeof(pS1)));
                    VERIFY_STATUS(cx_bn_alloc_init(&f2, sizeof(pS2), pS2, sizeof(pS2)));
                    VERIFY_STATUS(cx_bn_alloc_init(&fMod, sizeof(pS3), pS3, sizeof(pS3)));

                    Alert("scmulx10K", 0);

                    for (int i = 0; i < 10000; ++i)
                    {
                        if (!VERIFY_STATUS(cx_bn_mod_mul(f0, f1, f2, fMod)))
                            break;
                    }

                    Alert("scmulx10K", 1);

                }


                VERIFY_STATUS(cx_ecpoint_destroy(&pt2));
            }
            VERIFY_STATUS(cx_ecpoint_destroy(&pt1));
        }


        VERIFY_STATUS(cx_bn_unlock());
    }

}
